---
title: 'مشکل اصلی Web Components'
publishedAt: '2025-05-21'
summary: 'چرا استفاده از Web Components چالش‌برانگیز است و چگونه می‌توان از آن‌ها به درستی استفاده کرد.'
language: 'fa'
tags: ['webdev', 'html', 'webcomponents']
series: 'مهارت در Web Components'
seriesOrder: 2
draft: false
---

مشکل اصلی Web Components خیلی ساده‌ست: هیچ مسیر مشخص و واضحی برای استفاده درست ازشون وجود نداره. یه راهنمای جامع که بگی "از اینجا شروع کن و به اینجا برس" نیست. تا همین اواخر، این استاندارد مدام در حال تغییر بود — و راستش هنوزم یه جاهایی در حال تغییره. اما بخش‌های اصلی این تکنولوژی دیگه ثبات پیدا کرده و خیلی از برنامه‌نویسا دارن وارد این فضا می‌شن.

ولی اگه تا حالا روند رشد و تغییرات این استاندارد رو دنبال نکرده باشی، واقعاً نمی‌دونی از کجا باید شروع کنی. یاد گرفتن مفاهیم مورد نیاز برای استفاده از این ابزار قدرتمند، خودش یه چالش حسابی‌ه. مقاله زیاد هست، ولی اطلاعات به دردبخور این وسط گم‌وگوره، لای کلی آموزش قدیمی که با نسخه‌های آزمایشی نوشته شدن و حالا دیگه به‌روز نیستن.

پس اگه دنبال راهی برای ساخت کامپوننت‌های خودت از صفر هستی، جای درستی اومدی.

## ساختار یه Web Component

اول از همه باید بدونی مهم‌ترین ویژگی Web Components اینه که می‌تونی تگ‌های HTML سفارشی خودت رو بسازی. احتمالاً اسم HTML Templates و Shadow DOM هم به گوشت خورده. اینا ابزارایی‌ان که بهت کنترل بیشتری روی کپسوله‌سازی (مخفی کردن جزئیات داخلی) تو مرورگر می‌دن. ولی فعلاً نیازی نیست درگیر اون بخشا بشی. بذار اول ببینیم مرورگر چطور با تگ‌هایی که نمی‌شناسه برخورد می‌کنه.

## تگ‌های سفارشی چطور کار می‌کنن؟

وقتی مرورگر یه فایل HTML رو می‌خونه، برای هر تگ، یه عنصر می‌سازه. تگ‌هایی مثل `<div>`، `<p>` یا `<button>` برای مرورگرها آشنا هستن. ولی اگه یه تگ جدید بسازی چی؟

```html
<component></component>
```

مرورگرها نمی‌تونن با دیدن تگ‌های ناآشنا ارور بدن یا اطلاعات رو حذف کنن. پس میان این تگ‌ها رو به‌عنوان یه عنصر ناشناس (HTMLUnknownElement) در نظر می‌گیرن و محتوای داخلش رو نمایش می‌دن یا ادامه می‌دن به تجزیه بقیه‌ی تگ‌های داخلی.

این دقیقاً همون قابلیتیه که به ما اجازه می‌ده تگ‌های اختصاصی خودمون رو بسازیم.

## چطور یه تگ سفارشی تعریف کنیم؟

HTML یه سری تگ مشخص داره که خیلی به‌ندرت تغییر می‌کنن. تو زمان HTML5 چندتا تگ جدید اومد، ولی بعدش دیگه تغییر زیادی ندیدیم. قبلاً فقط می‌تونستیم با `<div>` و کلاس‌ها یه‌سری ساختار پیچیده بسازیم. حالا می‌تونیم اونا رو تبدیل کنیم به کامپوننت‌هایی که معنی و قابلیت استفاده‌ی مجدد دارن.

اما چون ممکنه تو آینده تگ‌های جدیدی به HTML اضافه بشه، ما اجازه نداریم از اسم‌های ساده برای تگ‌هامون استفاده کنیم. برای همین، تگ سفارشی حتماً باید یه خط تیره (-) تو اسمش داشته باشه.

مثلاً:

```html
<my-element>Hello World</my-element>

<my-next-element>
  <span>This</span>
  <span>is</span>
  <span>a</span>
  <span>test</span>
</my-next-element>
```

با این کار، به مرورگر می‌گیم: «نگران نباش، من خودم مسئول این تگ‌م!» حالا این تگ دیگه ناشناس نیست و مرورگر اونو مثل یه تگ معمولی — مثلاً یه `<span>` — پردازش می‌کنه.

## استایل دادن با CSS

می‌تونی به همین راحتی با CSS به تگ‌های سفارشی‌ات استایل بدی:

```css
my-element {
  display: block;
  padding: 1em;
  color: black;
  background: green;
}

my-next-element {
  display: flex;
  flex-flow: row wrap;
  justify-content: space-around;
}
```

## استفاده از JavaScript

همچنین خیلی راحت می‌تونی با جاوااسکریپت بهشون دسترسی داشته باشی:

```javascript
const myElement = document.querySelector('my-element');
console.log(myElement instanceof HTMLElement); // true

const myNextElement = document.querySelector('my-next-element');
console.log(myNextElement.children); // HTMLCollection(4)
```

و حتی می‌تونی براشون رویداد تعریف کنی، مثل بقیه‌ی تگ‌ها:

```javascript
myElement.addEventListener('click', (event) => {
  console.log(event.target);
});
```

ولی همه‌ی اینا فقط یه شروع ساده‌ست — دنیای Web Components خیلی گسترده‌تره!

## ثبت (Register) کردن یک تگ سفارشی

اگه بخوایم اون تگ سفارشی که ساختیم واقعاً یه کار خاص انجام بده و فقط یه تگ تزئینی نباشه، باید اون رو به مرورگر معرفی کنیم.

مثال:

```javascript
class MyElement extends HTMLElement {
  constructor() {
    super();
  }
}

customElements.define('my-element', MyElement);
```

تنها با همین کد، در ظاهر هنوز چیزی به اون تگی که قبلاً ساختیم اضافه نکردیم. اما این کار پایه و اساس یه کامپوننت ماژولار و قابل استفاده‌ مجدد رو فراهم می‌کنه.

قبل از اینکه مفهوم "Custom Elements" وارد وب بشه، مجبور بودیم صبر کنیم تا کل DOM بارگذاری بشه، بعد با JavaScript همه‌ی تگ‌هایی که می‌خواستیم رو پیدا کنیم و روشون یه سری ویژگی خاص پیاده کنیم.

اما حالا با استفاده از Custom Elements، می‌تونیم اون منطق و رفتار دلخواه رو مستقیماً داخل تعریف خود عنصر بنویسیم. دیگه نیازی نیست دنبال تگ‌هامون بگردیم. هر وقت مرورگر به اون تگ برسه، خودش خودکار از اون کلاسی که براش تعریف کردیم استفاده می‌کنه.

## استفاده از قدرت ماجرا

وقتی تگ سفارشی‌مون رو ثبت می‌کنیم، دیگه دست‌مون حسابی بازه.
می‌تونیم بچه‌های داخلش رو بررسی کنیم، ببینیم بچه جدید اضافه شد یا نه، بچه‌های خودمون رو بهش اضافه کنیم، یا هر جور دلمون می‌خواد تغییرش بدیم. همه‌چی بستگی به کاری داره که می‌خوایم انجام بدیم.
هر کامپوننت می‌تونه یه داستان متفاوت داشته باشه. واقعاً هیچ محدودیتی وجود نداره.

اما خب، باید از یه جایی شروع کرد.
بیایم با یه مثال ساده بریم جلو: یه تگ به اسم `<copy-text>` می‌سازیم. هر وقت روی این تگ کلیک بشه، متن داخلش کپی می‌شه توی کلیپ‌بورد.

معلومه که این کار رو با یه کم JavaScript و یه `<span>` هم می‌تونستیم انجام بدیم.
ولی وقتی یه تگ اختصاصی داشته باشیم، توی HTML خیلی واضح مشخص می‌شه که قراره چه کاری انجام بشه.

همچنین می‌تونیم تو CSS خیلی راحت براش استایل خاص بنویسیم، بدون اینکه بخوایم کلی کلاس یا آیدی براش تعریف کنیم.
و مهم‌تر اینکه: برای اضافه کردن نمونه‌های جدید از این عنصر، لازم نیست هیچ کدی رو تغییر بدیم!

<p
  class="codepen"
  data-height="300"
  data-default-tab="html,result"
  data-slug-hash="oggOVgq"
  data-pen-title="Copy Text Element"
  data-user="besworks-dev"
  style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;"
>
  <span>
    See the Pen{' '}
    <a href="https://codepen.io/besworks-dev/pen/oggOVgq">Copy Text Element</a>{' '}
    by Russell Beswick (
    <a href="https://codepen.io/besworks-dev">@besworks-dev</a>) on{' '}
    <a href="https://codepen.io">CodePen</a>.
  </span>
</p>
<script async src="https://public.codepenassets.com/embed/index.js"></script>

حتماً دقت کردی که توی تعریف کلاس از متدهای خصوصی با علامت # استفاده کردم. این کار باعث می‌شه بخش‌های داخلی کامپوننت‌مون از بیرون قابل دسترسی یا تغییر نباشه.
یعنی کسی نمی‌تونه بیاد و با جاوااسکریپت از بیرون بره سراغ منطق داخلی کامپوننت.

وقتی وارد بحث کپسوله‌سازی (Encapsulation) بشیم، این موضوع اهمیت بیشتری پیدا می‌کنه.
فعلاً کامپوننتی که ساختیم داره کاملاً توی سند اصلی (همون DOM ریشه) زندگی می‌کنه. یعنی CSS صفحه روش اعمال می‌شه، و می‌تونیم به راحتی از بیرون به ساختارش دسترسی داشته باشیم.

## استفاده‌ مجدد از عناصر سفارشی

نکته مهم اینه که یه Custom Element فقط یک بار توی هر صفحه (یا بهتر بگیم، توی هر context مرورگر) باید ثبت بشه.

یعنی همین که فایل جاوااسکریپت مربوط به اون کامپوننت رو — چه به صورت inline، چه به صورت ماژول جدا — یه بار توی صفحه لود کنیم، کافیه.
بعدش می‌تونیم هر چند بار که خواستیم ازش استفاده کنیم، تو هر جایی که دلمون خواست.

مثلاً:

```html
<!DOCTYPE html>
<title>مثال از عنصر copy-text</title>
<link rel="stylesheet" href="theme.css" />
<script type="module" src="copy-text.js"></script>

<div>
  <label>مثال:</label>
  <copy-text title="کلید API رو کپی کن">
    A_REALLY_LONG_API_KEY_OR_WHATEVER
  </copy-text>
</div>

<div>
  <label>مثال ۲:</label>
  <copy-text> یه متن دیگه برای کپی شدن </copy-text>
</div>
```

## استفاده از کلاس کامپوننت در جاهای دیگه

اگه کلاس رو از فایل ماژولمون خروجی بگیریم (export کنیم)، می‌تونیم توی فایل‌های دیگه هم اون رو وارد (import) کنیم و نمونه بسازیم:

```javascript
// آخر فایل copy-text.js
export { CopyTextElement };

// توی یه فایل دیگه:
import { CopyTextElement } from './copy-text.js';
const copyText = new CopyTextElement();
```

البته اگه مطمئن باشی که ماژولت قبلاً لود شده، نیازی به ایمپورت کردن نیست.
مستقیم می‌تونی یه عنصر بسازی:

```javascript
const copyText = document.createElement('copy-text');
```

یا حتی می‌تونی کلاس مربوط به اون تگ رو از رجیستری عناصر مرورگر بگیری:

```javascript
const CopyTextElement = customElements.get('copy-text');
const anotherCopy = new CopyTextElement();
```

اما اگه ترتیب بارگذاری ماژول‌ها توی صفحه دست خودت نیست، یعنی ممکنه مطمئن نباشی که اون تگ سفارشی کی ثبت شده، می‌تونی صبر کنی تا مطمئن بشی که تگ مورد نظرت ثبت شده:

```javascript
customElements.whenDefined('copy-text').then((CopyTextElement) => {
  const copyText = new CopyTextElement();
});
```

با این روش، تا وقتی کامپوننت آماده نشده، هیچ کاری انجام نمی‌دی. یه جور تضمینه برای اینکه کدت خطا نده.

## باید یه قدم عمیق‌تر بریم

تا اینجا فقط درباره‌ی این صحبت کردیم که یه تگ سفارشی (Custom Element) به تنهایی چطوری کار می‌کنه. حالا وقتشه بریم سراغ یه مرحله‌ی بالاتر: تگی که داخلش یه ساختار (زیرشاخه یا subtree) داره.

توی وب‌اپ‌های قدیمی، معمولاً می‌اومدیم و با انتخاب یه عنصر میزبان (host element)، به بچه‌های داخلش دسترسی پیدا می‌کردیم.
اما با استفاده از Custom Elements، خود اون تگ سفارشی می‌تونه مسئول بچه‌های خودش باشه!

برای اینکه بتونیم این موضوع رو خوب مدیریت کنیم، بهترین ابزارمون MutationObserver هست.

<p
  class="codepen"
  data-height="300"
  data-default-tab="html,result"
  data-slug-hash="qEEwwje"
  data-pen-title="ChildList Mutation Observer"
  data-user="besworks-dev"
  style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;"
>
  <span>
    See the Pen{' '}
    <a href="https://codepen.io/besworks-dev/pen/qEEwwje">
      ChildList Mutation Observer
    </a>{' '}
    by Russell Beswick (
    <a href="https://codepen.io/besworks-dev">@besworks-dev</a>) on{' '}
    <a href="https://codepen.io">CodePen</a>.
  </span>
</p>
<script async src="https://public.codepenassets.com/embed/index.js"></script>

ما می‌تونیم از همون اول هندلرهای مورد نیاز رو تنظیم کنیم و بعد هر وقت یه عنصر جدید وارد subtree بشه یا ازش حذف بشه، خودمون به‌صورت داینامیک هندلرش رو اضافه یا حذف کنیم.

دقت کن که همه‌ی این تنظیمات رو توی constructor انجام می‌دیم.
خیلی از آموزش‌ها تمرکزشون روی connectedCallback هست، ولی در واقع constructor جای درستیه برای راه‌اندازی منطق پایه‌ای کامپوننت.

دلیل اصلیش اینه که می‌خوایم تگ ما از همون لحظه‌ی ساخته شدن، آماده باشه تا با بچه‌هاش کار کنه. نمی‌خوایم صبر کنیم تا به DOM وصل بشه.
این یعنی می‌تونیم یه نمونه از اون تگ رو توی کد بسازیم، همه چیزش رو تنظیم کنیم، و بعد بندازیم توی صفحه — بدون اینکه بعدش نیاز به تغییر یا پردازش باشه.

تو مثالی که اینجا زدیم، فقط روی هندل کردن کلیک تمرکز کردیم، ولی این ساختار می‌تونه خیلی پیشرفته‌تر باشه و منطق پیچیده‌تری رو پیاده کنه.

```javascript
const clickHandler = document.createElement('click-handler');

['test', 'another', 'more'].forEach((label) => {
  const span = document.createElement('span');
  span.textContent = label;
  clickHandler.append(span);
});

requestAnimationFrame(() => {
  document.append(clickHandler);
});
```

## هم ساده، هم قدرتمند

تا اینجا دیدیم که چطور می‌تونیم با استفاده از Custom Elements، یه سری قابلیت قابل استفاده‌ مجدد رو به روشی ساده و ماژولار بسازیم — بدون نیاز به ابزارهای build، یا فریم‌ورک‌های خاص.
فقط با HTML معنادار، CSS معمولی، و جاوااسکریپت خالص.

یعنی Web Components واقعاً همه‌جا کار می‌کنن. ولی واقعیت اینه که تا اینجا فقط تونستیم روش‌های قبلی رو ساده‌تر و قابل استفاده‌ مجدد کنیم.
این ابزار کلی چیز دیگه هم برای ارائه داره!

## ادامه ماجرا…

توی مقاله بعدی، می‌ریم سراغ HTML Templates و می‌بینیم چطوری می‌تونیم تعریف‌های ساده و اعلامی (declarative) رو به ساختارهای پیچیده‌تر تبدیل کنیم.

همچنین به‌طور مفصل در مورد Shadow DOM صحبت می‌کنیم تا ببینیم چطور می‌شه کامپوننت‌هامون رو به‌طور کامل یا انتخابی کپسوله‌سازی کنیم.

تا اون موقع، پیشنهاد می‌کنم خودت دست به کار بشی و یه سری تگ سفارشی بسازی.
ساده شروع کن، و سعی کن واقعاً یه مشکلی رو حل کنی.

چندتا ایده برای شروع:

- `<format-number>` : عددها رو با فرمت خاص نمایش بده (مثل پول، اعشار، و غیره)
- `<tool-tip>` : وقتی موس روش می‌ره یا لمس می‌شه، یه توضیح کوچیک نشون بده
- `<marquee-text>` : یه ادای احترام به تگ قدیمی و غیر استاندارد `<marquee>`
- `<nav-bar>` : منوی سایت که خودش به‌صورت خودکار مسیر فعال (active route) رو برجسته می‌کنه

شروع کن، تست کن، و از ساختن لذت ببر!
